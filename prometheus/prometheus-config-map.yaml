apiVersion: v1
data:
  alert.rules: "## alert.rules ##\n\n#\n# CPU Alerts\n#\nALERT InstanceDown  \n  IF
    up == 0\n  FOR 10m\n  LABELS { severity = \"page\" }\n  ANNOTATIONS {\n    summary
    = \"Instance {{$labels.host}} is down\",\n    description = \"{{$labels.host}}
    of job {{$labels.job}} has been down for more than 5 minutes\"\n  }\nALERT InstanceLowMemory
    \ \n  IF node_memory_MemAvailable < 268435456\n  FOR 10m\n  LABELS { severity
    = \"page\" }\n  ANNOTATIONS {\n    summary = \"Instance {{$labels.host}} memory
    low\",\n    description = \"{{$labels.host}} has less than 256M memory available\"\n
    \ }\nALERT InstanceLowDisk  \n  IF node_filesystem_avail{mountpoint=\"/etc/hosts\"}
    < 10737418240\n  FOR 10m  LABELS { severity = \"page\" }\n  ANNOTATIONS {\n    summary
    = \"Instance {{$labels.host}} low disk space\",\n    description = \"{{$labels.host}}
    has less than 10G FS space\"\n  }\nALERT InstanceLowDisk  \n  IF node_filesystem_avail{mountpoint=\"/etc/hosts\"}
    < 10737418240\n  FOR 10m  LABELS { severity = \"page\" }\n  ANNOTATIONS {\n    summary
    = \"Instance {{$labels.host}} low disk space\",\n    description = \"{{$labels.host}}
    has less than 10G FS space\"\n  }\nALERT HighCPU\n  IF ((sum(node_cpu{mode=~\"user|nice|system|irq|softirq|steal|idle|iowait\"})
    by (instance, job)) - ( sum(node_cpu{mode=~\"idle|iowait\"}) by (instance,job)
    )   )   /  (sum(node_cpu{mode=~\"user|nice|system|irq|softirq|steal|idle|iowait\"})
    by (instance, job)) * 100 > 95\n  FOR 10m\n  LABELS { service = \"backend\" }\n
    \ ANNOTATIONS {\n    summary = \"High CPU Usage\",\n    description = \"This machine
    \ has really high CPU usage for over 10m\",\n  }\n\n#\n# DNS Lookup failures\n#\nALERT
    DNSLookupFailureFromPrometheus\n  IF prometheus_dns_sd_lookup_failures_total >
    5\n  FOR 1m\n  LABELS { service = \"frontend\" }\n  ANNOTATIONS {\n    summary
    = \"Prometheus reported over 5 DNS lookup failure\",\n    description = \"The
    prometheus unit reported that it failed to query the DNS.  Look at the kube-dns
    to see if it is having any problems\",\n  }"
  kubernetes.rules: |
  kubernetes.rules: |
    # NOTE: These rules were kindly contributed by the SoundCloud engineering team.

    ### Container resources ###

    cluster_namespace_controller_pod_container:spec_memory_limit_bytes =
      sum by (cluster,namespace,controller,pod_name,container_name) (
        label_replace(
          container_spec_memory_limit_bytes{container_name!=""},
          "controller", "$1",
          "pod_name", "^(.*)-[a-z0-9]+"
        )
      )

    cluster_namespace_controller_pod_container:spec_cpu_shares =
      sum by (cluster,namespace,controller,pod_name,container_name) (
        label_replace(
          container_spec_cpu_shares{container_name!=""},
          "controller", "$1",
          "pod_name", "^(.*)-[a-z0-9]+"
        )
      )

    cluster_namespace_controller_pod_container:cpu_usage:rate =
      sum by (cluster,namespace,controller,pod_name,container_name) (
        label_replace(
          irate(
            container_cpu_usage_seconds_total{container_name!=""}[5m]
          ),
          "controller", "$1",
          "pod_name", "^(.*)-[a-z0-9]+"
        )
      )
    cluster_namespace_controller_pod_container:memory_usage:bytes =
      sum by (cluster,namespace,controller,pod_name,container_name) (
        label_replace(
          container_memory_usage_bytes{container_name!=""},
          "controller", "$1",
          "pod_name", "^(.*)-[a-z0-9]+"
        )
      )

    cluster_namespace_controller_pod_container:memory_working_set:bytes =
      sum by (cluster,namespace,controller,pod_name,container_name) (
        label_replace(
          container_memory_working_set_bytes{container_name!=""},
          "controller", "$1",
          "pod_name", "^(.*)-[a-z0-9]+"
        )
      )

    cluster_namespace_controller_pod_container:memory_rss:bytes =
      sum by (cluster,namespace,controller,pod_name,container_name) (
        label_replace(
          container_memory_rss{container_name!=""},
          "controller", "$1",
          "pod_name", "^(.*)-[a-z0-9]+"
        )
      )

    cluster_namespace_controller_pod_container:memory_cache:bytes =
      sum by (cluster,namespace,controller,pod_name,container_name) (
        label_replace(
          container_memory_cache{container_name!=""},
          "controller", "$1",
          "pod_name", "^(.*)-[a-z0-9]+"
        )
      )
    cluster_namespace_controller_pod_container:disk_usage:bytes =
      sum by (cluster,namespace,controller,pod_name,container_name) (
        label_replace(
          container_disk_usage_bytes{container_name!=""},
          "controller", "$1",
          "pod_name", "^(.*)-[a-z0-9]+"
        )
      )

    cluster_namespace_controller_pod_container:memory_pagefaults:rate =
      sum by (cluster,namespace,controller,pod_name,container_name,scope,type) (
        label_replace(
          irate(
            container_memory_failures_total{container_name!=""}[5m]
          ),
          "controller", "$1",
          "pod_name", "^(.*)-[a-z0-9]+"
        )
      )

    cluster_namespace_controller_pod_container:memory_oom:rate =
      sum by (cluster,namespace,controller,pod_name,container_name,scope,type) (
        label_replace(
          irate(
            container_memory_failcnt{container_name!=""}[5m]
          ),
          "controller", "$1",
          "pod_name", "^(.*)-[a-z0-9]+"
        )
      )
    ### Cluster resources ###

    cluster:memory_allocation:bytes =
      sum by (cluster) (
        machine_memory_bytes
      )

    cluster:memory_allocation:percent =
      100 * sum by (cluster) (
        container_spec_memory_limit_bytes{pod_name!=""}
      ) / sum by (cluster) (
        machine_memory_bytes
      )

    cluster:memory_used:bytes =
      sum by (cluster) (
        container_memory_usage_bytes{pod_name!="",id="/"}
      )

    cluster:memory_used:percent =
      100 * sum by (cluster) (
        container_memory_usage_bytes{pod_name!="",id="/"}
      ) / sum by (cluster) (
        machine_memory_bytes
      )

    cluster:cpu_allocation:percent =
      100 * sum by (cluster) (
        container_spec_cpu_shares{pod_name!=""}
      ) / sum by (cluster) (
        container_spec_cpu_shares{id="/"} * on(cluster,instance) machine_cpu_cores
      )
    cluster:node_cpu_use:millicores =
      sum by (cluster) (
        rate(node_cpu{mode!="idle"}[5m])
      )

    cluster:node_cpu_use:percent =
      100 * sum by (cluster) (
        rate(node_cpu{mode!="idle"}[5m])
      ) / sum by (cluster) (
        machine_cpu_cores
      )

    ### API latency ###

    # Raw metrics are in microseconds. Convert to seconds.
    cluster_resource_verb:apiserver_latency:quantile_seconds{quantile="0.99"} =
      histogram_quantile(
        0.99,
        sum by(le,cluster,job,resource,verb) (apiserver_request_latencies_bucket)
      ) / 1e6
    cluster_resource_verb:apiserver_latency:quantile_seconds{quantile="0.9"} =
      histogram_quantile(
        0.9,
        sum by(le,cluster,job,resource,verb) (apiserver_request_latencies_bucket)
      ) / 1e6
    cluster_resource_verb:apiserver_latency:quantile_seconds{quantile="0.5"} =
      histogram_quantile(
        0.5,
        sum by(le,cluster,job,resource,verb) (apiserver_request_latencies_bucket)
      ) / 1e6
    ### Scheduling latency ###

    cluster:scheduler_e2e_scheduling_latency:quantile_seconds{quantile="0.99"} =
      histogram_quantile(0.99,sum by (le,cluster) (scheduler_e2e_scheduling_latency_microseconds_bucket)) / 1e6
    cluster:scheduler_e2e_scheduling_latency:quantile_seconds{quantile="0.9"} =
      histogram_quantile(0.9,sum by (le,cluster) (scheduler_e2e_scheduling_latency_microseconds_bucket)) / 1e6
    cluster:scheduler_e2e_scheduling_latency:quantile_seconds{quantile="0.5"} =
      histogram_quantile(0.5,sum by (le,cluster) (scheduler_e2e_scheduling_latency_microseconds_bucket)) / 1e6

    cluster:scheduler_scheduling_algorithm_latency:quantile_seconds{quantile="0.99"} =
      histogram_quantile(0.99,sum by (le,cluster) (scheduler_scheduling_algorithm_latency_microseconds_bucket)) / 1e6
    cluster:scheduler_scheduling_algorithm_latency:quantile_seconds{quantile="0.9"} =
      histogram_quantile(0.9,sum by (le,cluster) (scheduler_scheduling_algorithm_latency_microseconds_bucket)) / 1e6
    cluster:scheduler_scheduling_algorithm_latency:quantile_seconds{quantile="0.5"} =
      histogram_quantile(0.5,sum by (le,cluster) (scheduler_scheduling_algorithm_latency_microseconds_bucket)) / 1e6

    cluster:scheduler_binding_latency:quantile_seconds{quantile="0.99"} =
      histogram_quantile(0.99,sum by (le,cluster) (scheduler_binding_latency_microseconds_bucket)) / 1e6
    cluster:scheduler_binding_latency:quantile_seconds{quantile="0.9"} =
      histogram_quantile(0.9,sum by (le,cluster) (scheduler_binding_latency_microseconds_bucket)) / 1e6
    cluster:scheduler_binding_latency:quantile_seconds{quantile="0.5"} =
      histogram_quantile(0.5,sum by (le,cluster) (scheduler_binding_latency_microseconds_bucket)) / 1e6
    ALERT K8SNodeDown
      IF up{job="kubelets"} == 0
      FOR 1h
      LABELS {
        service = "k8s",
        severity = "warning"
      }
      ANNOTATIONS {
        summary = "Kubelet cannot be scraped",
        description = "Prometheus could not scrape a {{ $labels.job }} for more than one hour",
      }

    ALERT K8SNodeNotReady
      IF kube_node_status_ready{condition="true"} == 0
      FOR 1h
      LABELS {
        service = "k8s",
        severity = "warning",
      }
      ANNOTATIONS {
        summary = "Node status is NotReady",
        description = "The Kubelet on {{ $labels.node }} has not checked in with the API, or has set itself to NotReady, for more than an hour",
      }
    ALERT K8SManyNodesNotReady
      IF
        count by (cluster) (kube_node_status_ready{condition="true"} == 0) > 1
        AND
          (
            count by (cluster) (kube_node_status_ready{condition="true"} == 0)
          /
            count by (cluster) (kube_node_status_ready{condition="true"})
          ) > 0.2
      FOR 1m
      LABELS {
        service = "k8s",
        severity = "critical",
      }
      ANNOTATIONS {
        summary = "Many K8s nodes are Not Ready",
        description = "{{ $value }} K8s nodes (more than 10% of cluster {{ $labels.cluster }}) are in the NotReady state.",
      }

    ALERT K8SKubeletNodeExporterDown
      IF up{job="node-exporter"} == 0
      FOR 15m
      LABELS {
        service = "k8s",
        severity = "warning"
      }
      ANNOTATIONS {
        summary = "Kubelet node_exporter cannot be scraped",
        description = "Prometheus could not scrape a {{ $labels.job }} for more than one hour.",
      }
    ALERT K8SKubeletDown
      IF absent(up{job="kubelets"}) or count by (cluster) (up{job="kubelets"} == 0) / count by (cluster) (up{job="kubelets"}) > 0.1
      FOR 1h
      LABELS {
        service = "k8s",
        severity = "critical"
      }
      ANNOTATIONS {
        summary = "Many Kubelets cannot be scraped",
        description = "Prometheus failed to scrape more than 10% of kubelets, or all Kubelets have disappeared from service discovery.",
      }

    ALERT K8SApiserverDown
      IF up{job="kubernetes"} == 0
      FOR 15m
      LABELS {
        service = "k8s",
        severity = "warning"
      }
      ANNOTATIONS {
        summary = "API server unreachable",
        description = "An API server could not be scraped.",
      }
    # Disable for non HA kubernetes setups.
    ALERT K8SApiserverDown
      IF absent({job="kubernetes"}) or (count by(cluster) (up{job="kubernetes"} == 1) < count by(cluster) (up{job="kubernetes"}))
      FOR 5m
      LABELS {
        service = "k8s",
        severity = "critical"
      }
      ANNOTATIONS {
        summary = "API server unreachable",
        description = "Prometheus failed to scrape multiple API servers, or all API servers have disappeared from service discovery.",
      }

    ALERT K8SSchedulerDown
      IF absent(up{job="kube-scheduler"}) or (count by(cluster) (up{job="kube-scheduler"} == 1) == 0)
      FOR 5m
      LABELS {
        service = "k8s",
        severity = "critical",
      }
      ANNOTATIONS {
        summary = "Scheduler is down",
        description = "There is no running K8S scheduler. New pods are not being assigned to nodes.",
      }
    ALERT K8SControllerManagerDown
      IF absent(up{job="kube-controller-manager"}) or (count by(cluster) (up{job="kube-controller-manager"} == 1) == 0)
      FOR 5m
      LABELS {
        service = "k8s",
        severity = "critical",
      }
      ANNOTATIONS {
        summary = "Controller manager is down",
        description = "There is no running K8S controller manager. Deployments and replication controllers are not making progress.",
      }

    ALERT K8SMoreThanOneController
      IF count by (job,cluster) (up{job=~"kube-scheduler|kube-controller-manager"}) > 1
      FOR 5m
      LABELS {
        service = "k8s",
        severity = "critical",
      }
      ANNOTATIONS {
        summary = "More than one controller node is active",
        description = "There is more than one {{ $labels.job }} managing the cluster. Cluster behaviour is undefined.",
      }
    ALERT K8SConntrackTableFull
      IF 100*node_nf_conntrack_entries / node_nf_conntrack_entries_limit > 50
      FOR 10m
      LABELS {
        service = "k8s",
        severity = "warning"
      }
      ANNOTATIONS {
        summary = "Number of tracked connections is near the limit",
        description = "The nf_conntrack table is {{ $value }}% full.",
      }

    ALERT K8SConntrackTableFull
      IF 100*node_nf_conntrack_entries / node_nf_conntrack_entries_limit > 90
      LABELS {
        service = "k8s",
        severity = "critical"
      }
      ANNOTATIONS {
        summary = "Number of tracked connections is near the limit",
        description = "The nf_conntrack table is {{ $value }}% full.",
      }

    # To catch the conntrack sysctl de-tuning when it happens
    ALERT K8SConntrackTuningMissing
      IF node_nf_conntrack_udp_timeout > 10
      FOR 10m
      LABELS {
        service = "k8s",
        severity = "warning",
      }
      ANNOTATIONS {
        summary = "Node does not have the correct conntrack tunings",
        description = "Nodes keep un-setting the correct tunings, investigate when it happens.",
      }
    ALERT K8STooManyOpenFiles
      IF 100*process_open_fds{job=~"kubelets|kubernetes"} / process_max_fds > 50
      FOR 10m
      LABELS {
        service = "k8s",
        severity = "warning"
      }
      ANNOTATIONS {
        summary = "{{ $labels.job }} has too many open file descriptors",
        description = "{{ $labels.node }} is using {{ $value }}% of the available file/socket descriptors.",
      }

    ALERT K8STooManyOpenFiles
      IF 100*process_open_fds{job=~"kubelets|kubernetes"} / process_max_fds > 80
      FOR 10m
      LABELS {
        service = "k8s",
        severity = "critical"
      }
      ANNOTATIONS {
        summary = "{{ $labels.job }} has too many open file descriptors",
        description = "{{ $labels.node }} is using {{ $value }}% of the available file/socket descriptors.",
      }
    # Some verbs excluded because they are expected to be long-lasting:
    # WATCHLIST is long-poll, CONNECT is `kubectl exec`.
    ALERT K8SApiServerLatency
      IF histogram_quantile(
          0.99,
          sum without (instance,node,resource) (apiserver_request_latencies_bucket{verb!~"CONNECT|WATCHLIST|WATCH"})
        ) / 1e6 > 1.0
      FOR 10m
      LABELS {
        service = "k8s",
        severity = "warning"
      }
      ANNOTATIONS {
        summary = "Kubernetes apiserver latency is high",
        description = "99th percentile Latency for {{ $labels.verb }} requests to the kube-apiserver is higher than 1s.",
      }

    ALERT K8SApiServerEtcdAccessLatency
      IF etcd_request_latencies_summary{quantile="0.99"} / 1e6 > 1.0
      FOR 15m
      LABELS {
        service = "k8s",
        severity = "warning"
      }
      ANNOTATIONS {
        summary = "Access to etcd is slow",
        description = "99th percentile latency for apiserver to access etcd is higher than 1s.",
      }
    ALERT K8SKubeletTooManyPods
      IF kubelet_running_pod_count > 100
      LABELS {
        service = "k8s",
        severity = "warning",
      }
      ANNOTATIONS {
        summary = "Kubelet is close to pod limit",
        description = "Kubelet {{$labels.instance}} is running {{$value}} pods, close to the limit of 110",
      }
  prometheus.yml: "global:\n  scrape_interval: 5s\n  evaluation_interval: 5s\n\nrule_files:\n-
    '/etc/prometheus/*.rules'  \nscrape_configs:\n  - job_name: kubelets-https\n    scheme:
    https\n    tls_config:\n      ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt\n
    \     insecure_skip_verify: true\n    bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token\n
    \   kubernetes_sd_configs:\n    - role: node\n  - job_name: standard-endpoints\n
    \   tls_config:\n      ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt\n
    \     insecure_skip_verify: true\n    bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token\n
    \   kubernetes_sd_configs:\n    - role: endpoints\n    relabel_configs:\n    -
    action: keep\n      source_labels: [__meta_kubernetes_service_name]\n      regex:
    prometheus|kubernetes|node-exporter|kube-state-metrics|etcd-k8s\n    - action:
    replace\n      source_labels: [__meta_kubernetes_service_name]\n      target_label:
    job\n    - action: replace\n      source_labels: [__meta_kubernetes_service_name]\n
    \     regex: kubernetes\n      target_label: __scheme__\n      replacement: https\n\n
    \ - job_name: kube-components\n    tls_config:\n      ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt\n
    \   bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token\n    kubernetes_sd_configs:\n
    \   - role: endpoints\n    relabel_configs:\n    - action: replace\n      source_labels:
    [__meta_kubernetes_service_name]\n      target_label: job\n      regex: \"kube-(.*)-prometheus-discovery\"\n
    \     replacement: \"kube-${1}\"\n    - action: keep\n      source_labels: [__meta_kubernetes_service_name]\n
    \     regex: \"kube-(.*)-prometheus-discovery\"\n    - action: keep\n      source_labels:
    [__meta_kubernetes_endpoint_port_name]\n      regex: \"prometheus\"\n\n  - job_name:
    'kubernetes-apiservers'\n    kubernetes_sd_configs:\n    - role: endpoints\n    scheme:
    https\n    tls_config:\n      ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt\n
    \     insecure_skip_verify: true\n    bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token\n
    \   relabel_configs:\n    - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name,
    __meta_kubernetes_endpoint_port_name]\n      action: keep\n      regex: default;kubernetes;https\n
    \ - job_name: 'kubernetes-nodes'\n    scheme: https\n    tls_config:\n      ca_file:
    /var/run/secrets/kubernetes.io/serviceaccount/ca.crt\n    bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token\n
    \   kubernetes_sd_configs:\n    - role: node\n    relabel_configs:\n    - action:
    labelmap\n      regex: __meta_kubernetes_node_label_(.+)\n    - target_label:
    __address__\n      replacement: kubernetes.default.svc:443\n    - source_labels:
    [__meta_kubernetes_node_name]\n      regex: (.+)\n      target_label: __metrics_path__\n
    \     replacement: /api/v1/nodes/${1}/proxy/metrics\n  \n  - job_name: 'kubernetes-pods'\n
    \   kubernetes_sd_configs:\n    - role: pod\n    relabel_configs:\n    - source_labels:
    [__meta_kubernetes_pod_annotation_prometheus_io_scrape]\n      action: keep\n
    \     regex: true\n    - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]\n
    \     action: replace\n      target_label: __metrics_path__\n      regex: (.+)\n
    \   - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]\n
    \     action: replace\n      regex: ([^:]+)(?::\\d+)?;(\\d+)\n      replacement:
    $1:$2\n      target_label: __address__\n    - action: labelmap\n      regex: __meta_kubernetes_pod_label_(.+)\n
    \   - source_labels: [__meta_kubernetes_namespace]\n      action: replace\n      target_label:
    kubernetes_namespace\n    - source_labels: [__meta_kubernetes_pod_name]\n      action:
    replace\n      target_label: kubernetes_pod_name\n\n  - job_name: 'kubernetes-cadvisor'\n
    \   scheme: https\n    tls_config:\n      ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt\n
    \   bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token\n    kubernetes_sd_configs:\n
    \   - role: node\n    relabel_configs:\n    - action: labelmap\n      regex: __meta_kubernetes_node_label_(.+)\n
    \   - target_label: __address__\n      replacement: kubernetes.default.svc:443\n
    \   - source_labels: [__meta_kubernetes_node_name]\n      regex: (.+)\n      target_label:
    __metrics_path__\n      replacement: /api/v1/nodes/${1}/proxy/metrics/cadvisor\n
    \ \n  - job_name: 'kubernetes-service-endpoints'\n    kubernetes_sd_configs:\n
    \   - role: endpoints\n    relabel_configs:\n    - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_probe]\n
    \     action: keep\n      regex: \"local\"\n    - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape]\n
    \     action: keep\n      regex: true\n    - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scheme]\n
    \     action: replace\n      target_label: __scheme__\n      regex: (https?)\n
    \   - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_path]\n
    \     action: replace\n      target_label: __metrics_path__\n      regex: (.+)\n
    \   - source_labels: [__address__, __meta_kubernetes_service_annotation_prometheus_io_port]\n
    \     action: replace\n      target_label: __address__\n      regex: ([^:]+)(?::\\d+)?;(\\d+)\n
    \     replacement: $1:$2\n    - action: labelmap\n      regex: __meta_kubernetes_service_label_(.+)\n
    \   - source_labels: [__meta_kubernetes_namespace]\n      action: replace\n      target_label:
    kubernetes_namespace\n    - source_labels: [__meta_kubernetes_service_name]\n
    \     action: replace\n      target_label: kubernetes_name"  
kind: ConfigMap
metadata:
  labels:
    name: prometheus-server-conf
  name: prometheus-server-conf
  namespace: monitoring
